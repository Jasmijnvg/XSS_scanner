package com.jasmi.xss_scanner.services;

import com.jasmi.xss_scanner.dtos.*;
import com.jasmi.xss_scanner.exceptions.RecordNotFoundException;
import com.jasmi.xss_scanner.mappers.SolutionMapper;
import com.jasmi.xss_scanner.mappers.VulnerabilityMapper;
import com.jasmi.xss_scanner.models.Solution;
import com.jasmi.xss_scanner.models.Vulnerability;
import com.jasmi.xss_scanner.repositories.SolutionRepository;
import com.jasmi.xss_scanner.repositories.VulnerabilityRepository;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class VulnerabilityService {
    private final VulnerabilityRepository vulnerabilityRepository;
    private final VulnerabilityMapper vulnerabilityMapper;
    private final SolutionMapper solutionMapper;
    private final SolutionRepository solutionRepository;

    public VulnerabilityService(VulnerabilityRepository vulnerabilityRepository, VulnerabilityMapper vulnerabilityMapper, SolutionMapper solutionMapper, SolutionRepository solutionRepository) {
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.vulnerabilityMapper = vulnerabilityMapper;
        this.solutionMapper = solutionMapper;
        this.solutionRepository = solutionRepository;
    }

    public List<VulnerabilityOutputDto> getAllVulnerabilities() {
        return vulnerabilityRepository.findAll()
                .stream()
                .map((x)->vulnerabilityMapper.toVulnerabilityDto(x))
                .collect(Collectors.toList());
    }

    public VulnerabilityOutputDto getVulnerabilityById(long id) {
        Optional<Vulnerability> optionalVulnerability = vulnerabilityRepository.findById(id);
        if (optionalVulnerability.isPresent()) {
            Vulnerability v = optionalVulnerability.get();
            return vulnerabilityMapper.toVulnerabilityDto(v);
        }
        else {
            throw new RecordNotFoundException("Vulnerability " + id + " not found");
        }
    }

    public VulnerabilityOutputDto saveVulnerability(VulnerabilityInputDto vulnerabilityInputDto) {
        Vulnerability v = vulnerabilityMapper.toVulnerability(vulnerabilityInputDto);
        Vulnerability savedVulnerability = vulnerabilityRepository.save(v);
        return vulnerabilityMapper.toVulnerabilityDto(savedVulnerability);
    }

    public void assignSolutionToVulnerability(long vulnerabilityId, SolutionInputDto solutionInputDto) {
        Vulnerability vulnerability = vulnerabilityRepository.findById(vulnerabilityId)
                .orElseThrow(() -> new RecordNotFoundException("Vulnerability "+vulnerabilityId+" not found"));

        Solution solution = solutionMapper.toSolution(solutionInputDto);
        solution.setVulnerability(vulnerability);

            if (vulnerability.getSolutions() != null) {
                vulnerability.getSolutions().add(solution);
            } else {
                List<Solution> solutions = new ArrayList<>();
                solutions.add(solution);
                vulnerability.setSolutions(solutions);
            }

            vulnerabilityRepository.save(vulnerability);
    }

    public VulnerabilityOutputDto updateVulnerability(long id, VulnerabilityInputDto updatedVulnerability) {
       if(!vulnerabilityRepository.existsById(id)){
           throw new RecordNotFoundException("Vulnerability "+id+" not found");
       }
        Vulnerability v = vulnerabilityMapper.toVulnerability(updatedVulnerability);
        v.setId(id);
        Vulnerability vulnerability = vulnerabilityRepository.save(v);
        return vulnerabilityMapper.toVulnerabilityDto(vulnerability);

    }

    public void deleteVulnerability(long id) {
        if(vulnerabilityRepository.existsById(id)){
            vulnerabilityRepository.deleteById(id);
        }
        else{
            throw new RecordNotFoundException("Vulnerability "+id+" not found");
        }
    }
}
